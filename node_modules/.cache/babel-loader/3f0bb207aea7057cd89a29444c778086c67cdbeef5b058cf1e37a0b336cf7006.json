{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\EnkiE\\\\Documents\\\\builds\\\\react-docs-main-concepts\\\\src\\\\index.js\";\n// A package that provides DOM specific methods that can be used at the top level of your app. \nimport { createRoot } from \"react-dom\";\nimport { createElement } from \"react\";\n// Creates a React root for the supplied div container, and then returns the root to be assigned to variable. The root is used \n// to render elements into the DOM using render(). Its called the root DOM node, because everything inside it is managed by reactDOM.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst root = createRoot(document.getElementById('root'));\nconst name = 'Enki';\n// This is JSX, it stands for JS XML. It is neither a string, nor HTML. It is a syntax extension to JS, and is used to describe\n// what the ui should look like in React. It produces React elements. React doesnt require JSX, but its a helpful visual aid, and  \n// supplies more error messages. \n// You can embed any valid JS expression into JSX using curly braces.\n// Elements may be confused with components, but elements are individual objects that define the DOM tree, where as components are\n// made up of elements, and are utilized to group them together for reusability. \nconst element = /*#__PURE__*/_jsxDEV(\"h1\", {\n  children: [\"Hello \", name]\n}, void 0, true, {\n  fileName: _jsxFileName,\n  lineNumber: 15,\n  columnNumber: 17\n}, this);\nconst nameFunc = user => `${user.firstName} ${user.lastName}`;\nconst user = {\n  firstName: 'Enki',\n  lastName: 'Winters'\n};\nconst userElement = /*#__PURE__*/_jsxDEV(\"h1\", {\n  children: [\"Hello, \", nameFunc(user)]\n}, void 0, true, {\n  fileName: _jsxFileName,\n  lineNumber: 22,\n  columnNumber: 21\n}, this);\n\n//After compilation JSX expressions become React.createElement calls, which evaluate to objects describing an DOM element. ReactDOM\n// usees these objects to tell the DOM what to render. Since JSX is also an expression you can use it any way you would use regular \n// JS expressions. The objects returned by createElement are called React elements. \nfunction getGreeting(user) {\n  if (user) {\n    return /*#__PURE__*/_jsxDEV(\"h1\", {\n      children: [\"Hello, \", nameFunc(user), \"!\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 14\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"h1\", {\n    children: \"Hello, Stranger.\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 31,\n    columnNumber: 12\n  }, this);\n}\n\n//You do not have to use JSX with React, to showcase that this is the React.createElement equivalent of the userElement JSX above.\n// createElement takes 3 arguments, a string representing the tag youd like the elemnet to represent, an object containing all the\n// props that will be passed to the element, and then the children the element will wrap around, it can be JSX, additional createElement\n// calls, or a string for text that should be rendered. createElement also performs a few checks to help you write bug free code.\nconst createdElement = /*#__PURE__*/createElement('h1', {}, `Yo, ${nameFunc(user)}!`);\n\n// Takes in an element utilizing it to keep the DOM updated. Can only render one element, and only one call works at a time. \n// So you should have a primary App component that is the parent of all other elements within the application. \nroot.render(element);\nroot.render(getGreeting(user));\nroot.render(createdElement);","map":{"version":3,"names":["createRoot","createElement","root","document","getElementById","name","element","nameFunc","user","firstName","lastName","userElement","getGreeting","createdElement","render"],"sources":["C:/Users/EnkiE/Documents/builds/react-docs-main-concepts/src/index.js"],"sourcesContent":["// A package that provides DOM specific methods that can be used at the top level of your app. \r\nimport {createRoot} from \"react-dom\";\r\nimport {createElement} from \"react\";\r\n// Creates a React root for the supplied div container, and then returns the root to be assigned to variable. The root is used \r\n// to render elements into the DOM using render(). Its called the root DOM node, because everything inside it is managed by reactDOM.\r\nconst root = createRoot(document.getElementById('root'))\r\n\r\nconst name = 'Enki'\r\n// This is JSX, it stands for JS XML. It is neither a string, nor HTML. It is a syntax extension to JS, and is used to describe\r\n// what the ui should look like in React. It produces React elements. React doesnt require JSX, but its a helpful visual aid, and  \r\n// supplies more error messages. \r\n// You can embed any valid JS expression into JSX using curly braces.\r\n// Elements may be confused with components, but elements are individual objects that define the DOM tree, where as components are\r\n// made up of elements, and are utilized to group them together for reusability. \r\nconst element = <h1>Hello {name}</h1>   \r\n\r\nconst nameFunc = user => `${user.firstName} ${user.lastName}`\r\nconst user = {\r\n    firstName: 'Enki',\r\n    lastName: 'Winters'\r\n}\r\nconst userElement = <h1>Hello, {nameFunc(user)}</h1>\r\n\r\n//After compilation JSX expressions become React.createElement calls, which evaluate to objects describing an DOM element. ReactDOM\r\n// usees these objects to tell the DOM what to render. Since JSX is also an expression you can use it any way you would use regular \r\n// JS expressions. The objects returned by createElement are called React elements. \r\nfunction getGreeting(user) {\r\n    if (user) {\r\n      return <h1>Hello, {nameFunc(user)}!</h1>;\r\n    }\r\n    return <h1>Hello, Stranger.</h1>;\r\n  }\r\n\r\n\r\n  //You do not have to use JSX with React, to showcase that this is the React.createElement equivalent of the userElement JSX above.\r\n// createElement takes 3 arguments, a string representing the tag youd like the elemnet to represent, an object containing all the\r\n// props that will be passed to the element, and then the children the element will wrap around, it can be JSX, additional createElement\r\n// calls, or a string for text that should be rendered. createElement also performs a few checks to help you write bug free code.\r\n  const createdElement = createElement(\r\n    'h1',\r\n    {},\r\n    `Yo, ${nameFunc(user)}!`\r\n  )\r\n\r\n// Takes in an element utilizing it to keep the DOM updated. Can only render one element, and only one call works at a time. \r\n// So you should have a primary App component that is the parent of all other elements within the application. \r\nroot.render(element)\r\nroot.render(getGreeting(user))\r\nroot.render(createdElement)"],"mappings":";AAAA;AACA,SAAQA,UAAU,QAAO,WAAW;AACpC,SAAQC,aAAa,QAAO,OAAO;AACnC;AACA;AAAA;AACA,MAAMC,IAAI,GAAGF,UAAU,CAACG,QAAQ,CAACC,cAAc,CAAC,MAAM,CAAC,CAAC;AAExD,MAAMC,IAAI,GAAG,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,gBAAG;EAAA,qBAAWD,IAAI;AAAA;EAAA;EAAA;EAAA;AAAA,QAAM;AAErC,MAAME,QAAQ,GAAGC,IAAI,IAAK,GAAEA,IAAI,CAACC,SAAU,IAAGD,IAAI,CAACE,QAAS,EAAC;AAC7D,MAAMF,IAAI,GAAG;EACTC,SAAS,EAAE,MAAM;EACjBC,QAAQ,EAAE;AACd,CAAC;AACD,MAAMC,WAAW,gBAAG;EAAA,sBAAYJ,QAAQ,CAACC,IAAI,CAAC;AAAA;EAAA;EAAA;EAAA;AAAA,QAAM;;AAEpD;AACA;AACA;AACA,SAASI,WAAW,CAACJ,IAAI,EAAE;EACvB,IAAIA,IAAI,EAAE;IACR,oBAAO;MAAA,sBAAYD,QAAQ,CAACC,IAAI,CAAC;IAAA;MAAA;MAAA;MAAA;IAAA,QAAO;EAC1C;EACA,oBAAO;IAAA;EAAA;IAAA;IAAA;IAAA;EAAA,QAAyB;AAClC;;AAGA;AACF;AACA;AACA;AACE,MAAMK,cAAc,gBAAGZ,aAAa,CAClC,IAAI,EACJ,CAAC,CAAC,EACD,OAAMM,QAAQ,CAACC,IAAI,CAAE,GAAE,CACzB;;AAEH;AACA;AACAN,IAAI,CAACY,MAAM,CAACR,OAAO,CAAC;AACpBJ,IAAI,CAACY,MAAM,CAACF,WAAW,CAACJ,IAAI,CAAC,CAAC;AAC9BN,IAAI,CAACY,MAAM,CAACD,cAAc,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}