{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\EnkiE\\\\Documents\\\\builds\\\\react-docs-main-concepts\\\\src\\\\index.js\";\n// A package that provides DOM specific methods that can be used at the top level of your app. \nimport { createRoot } from \"react-dom/client\";\nimport { createElement } from \"react\";\nimport App from './App';\n// Creates a React root for the supplied div container, and then returns the root to be assigned to variable. The root is used \n// to render elements into the DOM using render(). Its called the root DOM node, because everything inside it is managed by reactDOM.\n// Apps built with just React will typically have one root, but if integrating into an old project there may be many.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst root = createRoot(document.getElementById('root'));\nconst name = 'Enki';\n// This is JSX, it stands for JS XML. It is neither a string, nor HTML. It is a syntax extension to JS, and is used to describe\n// what the ui should look like in React. It produces React elements. React doesnt require JSX, but its a helpful visual aid, and  \n// supplies more error messages. \n// You can embed any valid JS expression into JSX using curly braces.\n// Elements may be confused with components, but elements are individual objects that define the DOM tree, where as components are\n// made up of elements, and are utilized to group them together for reusability. \n// to make JSX more readable write it over multiple lines, to avoid automatic semicolon insertion wrap it in parentheses.\nconst element = /*#__PURE__*/_jsxDEV(\"h1\", {\n  children: [\"Hello \", name]\n}, void 0, true, {\n  fileName: _jsxFileName,\n  lineNumber: 20,\n  columnNumber: 5\n}, this);\nconst nameFunc = user => `${user.firstName} ${user.lastName}`;\nconst user = {\n  firstName: 'Enki',\n  lastName: 'Winters'\n};\nconst userElement = /*#__PURE__*/_jsxDEV(\"h1\", {\n  children: [\"Hello, \", nameFunc(user)]\n}, void 0, true, {\n  fileName: _jsxFileName,\n  lineNumber: 30,\n  columnNumber: 21\n}, this);\n\n//After compilation JSX expressions become React.createElement calls, which evaluate to objects describing an DOM element. ReactDOM\n// usees these objects to tell the DOM what to render. Since JSX is also an expression you can use it any way you would use regular \n// JS expressions. The objects returned by createElement are called React elements. \nfunction getGreeting(user) {\n  if (user) {\n    return /*#__PURE__*/_jsxDEV(\"h1\", {\n      children: [\"Hello, \", nameFunc(user), \"!\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 14\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"h1\", {\n    children: \"Hello, Stranger.\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 39,\n    columnNumber: 12\n  }, this);\n}\n\n//You do not have to use JSX with React, to showcase that this is the React.createElement equivalent of the userElement JSX above.\n// createElement takes 3 arguments, a string representing the tag youd like the elemnet to represent, an object containing all the\n// props that will be passed to the element, and then the children the element will wrap around, it can be JSX, additional createElement\n// calls, or a string for text that should be rendered. createElement also performs a few checks to help you write bug free code.\nconst createdElement = /*#__PURE__*/createElement('h1', null, `Yo, ${nameFunc(user)}!`);\n\n// React elements are immutable, theyre like a single frame in a movie. With knowledge up to this point, the only way to update the\n// UI is to pass a new element to root.render. Here's an example of the UI being continuously updated in this way.\n\nfunction tick() {\n  // React element that embeds a Date object call, showing locale time\n  // Whenever you save in your editor the code is recompiled. ReactDOM compares previous React elements and their children to\n  // the new ones, and only rerenders elements that have changes. Even though we're passing a new element describing the UI tree\n  // on every setInteerval call if an element has no changes it isnt updated, because it has already been rendered. This is why\n  // React has such good performance.\n  const dateElement = /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Hello world\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n      children: [\"It is \", new Date().toLocaleTimeString()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 64,\n    columnNumber: 9\n  }, this);\n  // renders the element to the DOM\n  return root.render(dateElement);\n}\n// Takes in the tick function as a callback, and sets up the browser feature timer to asynchronously call the tick function every\n// second. Because it is asynchronous, it's really added to the callback queue every second, and then only invoked after the event\n// loop indicates the global execution context has popped off the call stack. \n// setInterval(tick, 1000)\n\n// Takes in an element utilizing it to keep the DOM updated. Can only render one element, and only one call works at a time. \n// So you should have a primary App component that is the parent of all other elements within the application. \nroot.render(element);\nroot.render(getGreeting(user));\nroot.render(createdElement);\nroot.render( /*#__PURE__*/_jsxDEV(App, {}, void 0, false, {\n  fileName: _jsxFileName,\n  lineNumber: 82,\n  columnNumber: 13\n}, this));","map":{"version":3,"names":["createRoot","createElement","App","root","document","getElementById","name","element","nameFunc","user","firstName","lastName","userElement","getGreeting","createdElement","tick","dateElement","Date","toLocaleTimeString","render"],"sources":["C:/Users/EnkiE/Documents/builds/react-docs-main-concepts/src/index.js"],"sourcesContent":["// A package that provides DOM specific methods that can be used at the top level of your app. \r\nimport {createRoot} from \"react-dom/client\";\r\nimport {createElement} from \"react\";\r\nimport App from './App'\r\n// Creates a React root for the supplied div container, and then returns the root to be assigned to variable. The root is used \r\n// to render elements into the DOM using render(). Its called the root DOM node, because everything inside it is managed by reactDOM.\r\n// Apps built with just React will typically have one root, but if integrating into an old project there may be many.\r\n\r\nconst root = createRoot(document.getElementById('root'))\r\n\r\nconst name = 'Enki'\r\n// This is JSX, it stands for JS XML. It is neither a string, nor HTML. It is a syntax extension to JS, and is used to describe\r\n// what the ui should look like in React. It produces React elements. React doesnt require JSX, but its a helpful visual aid, and  \r\n// supplies more error messages. \r\n// You can embed any valid JS expression into JSX using curly braces.\r\n// Elements may be confused with components, but elements are individual objects that define the DOM tree, where as components are\r\n// made up of elements, and are utilized to group them together for reusability. \r\n// to make JSX more readable write it over multiple lines, to avoid automatic semicolon insertion wrap it in parentheses.\r\nconst element = (\r\n    <h1>\r\n        Hello {name}\r\n    </h1> \r\n    )  \r\n\r\nconst nameFunc = user => `${user.firstName} ${user.lastName}`\r\nconst user = {\r\n    firstName: 'Enki',\r\n    lastName: 'Winters'\r\n}\r\nconst userElement = <h1>Hello, {nameFunc(user)}</h1>\r\n\r\n//After compilation JSX expressions become React.createElement calls, which evaluate to objects describing an DOM element. ReactDOM\r\n// usees these objects to tell the DOM what to render. Since JSX is also an expression you can use it any way you would use regular \r\n// JS expressions. The objects returned by createElement are called React elements. \r\nfunction getGreeting(user) {\r\n    if (user) {\r\n      return <h1>Hello, {nameFunc(user)}!</h1>;\r\n    }\r\n    return <h1>Hello, Stranger.</h1>;\r\n  }\r\n\r\n\r\n//You do not have to use JSX with React, to showcase that this is the React.createElement equivalent of the userElement JSX above.\r\n// createElement takes 3 arguments, a string representing the tag youd like the elemnet to represent, an object containing all the\r\n// props that will be passed to the element, and then the children the element will wrap around, it can be JSX, additional createElement\r\n// calls, or a string for text that should be rendered. createElement also performs a few checks to help you write bug free code.\r\n  const createdElement = createElement(\r\n    'h1',\r\n    null,\r\n    `Yo, ${nameFunc(user)}!`\r\n  )\r\n\r\n\r\n// React elements are immutable, theyre like a single frame in a movie. With knowledge up to this point, the only way to update the\r\n// UI is to pass a new element to root.render. Here's an example of the UI being continuously updated in this way.\r\n\r\nfunction tick(){\r\n    // React element that embeds a Date object call, showing locale time\r\n    // Whenever you save in your editor the code is recompiled. ReactDOM compares previous React elements and their children to\r\n    // the new ones, and only rerenders elements that have changes. Even though we're passing a new element describing the UI tree\r\n    // on every setInteerval call if an element has no changes it isnt updated, because it has already been rendered. This is why\r\n    // React has such good performance.\r\n    const dateElement = (\r\n        <div>\r\n            <h1>Hello world</h1>\r\n            <h1>It is {new Date().toLocaleTimeString()}</h1>\r\n        </div>\r\n    )\r\n    // renders the element to the DOM\r\n    return root.render(dateElement)\r\n}\r\n// Takes in the tick function as a callback, and sets up the browser feature timer to asynchronously call the tick function every\r\n// second. Because it is asynchronous, it's really added to the callback queue every second, and then only invoked after the event\r\n// loop indicates the global execution context has popped off the call stack. \r\n// setInterval(tick, 1000)\r\n\r\n// Takes in an element utilizing it to keep the DOM updated. Can only render one element, and only one call works at a time. \r\n// So you should have a primary App component that is the parent of all other elements within the application. \r\nroot.render(element)\r\nroot.render(getGreeting(user))\r\nroot.render(createdElement)\r\nroot.render(<App/>)"],"mappings":";AAAA;AACA,SAAQA,UAAU,QAAO,kBAAkB;AAC3C,SAAQC,aAAa,QAAO,OAAO;AACnC,OAAOC,GAAG,MAAM,OAAO;AACvB;AACA;AACA;AAAA;AAEA,MAAMC,IAAI,GAAGH,UAAU,CAACI,QAAQ,CAACC,cAAc,CAAC,MAAM,CAAC,CAAC;AAExD,MAAMC,IAAI,GAAG,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,gBACT;EAAA,qBACWD,IAAI;AAAA;EAAA;EAAA;EAAA;AAAA,QAEd;AAEL,MAAME,QAAQ,GAAGC,IAAI,IAAK,GAAEA,IAAI,CAACC,SAAU,IAAGD,IAAI,CAACE,QAAS,EAAC;AAC7D,MAAMF,IAAI,GAAG;EACTC,SAAS,EAAE,MAAM;EACjBC,QAAQ,EAAE;AACd,CAAC;AACD,MAAMC,WAAW,gBAAG;EAAA,sBAAYJ,QAAQ,CAACC,IAAI,CAAC;AAAA;EAAA;EAAA;EAAA;AAAA,QAAM;;AAEpD;AACA;AACA;AACA,SAASI,WAAW,CAACJ,IAAI,EAAE;EACvB,IAAIA,IAAI,EAAE;IACR,oBAAO;MAAA,sBAAYD,QAAQ,CAACC,IAAI,CAAC;IAAA;MAAA;MAAA;MAAA;IAAA,QAAO;EAC1C;EACA,oBAAO;IAAA;EAAA;IAAA;IAAA;IAAA;EAAA,QAAyB;AAClC;;AAGF;AACA;AACA;AACA;AACE,MAAMK,cAAc,gBAAGb,aAAa,CAClC,IAAI,EACJ,IAAI,EACH,OAAMO,QAAQ,CAACC,IAAI,CAAE,GAAE,CACzB;;AAGH;AACA;;AAEA,SAASM,IAAI,GAAE;EACX;EACA;EACA;EACA;EACA;EACA,MAAMC,WAAW,gBACb;IAAA,wBACI;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QAAoB,eACpB;MAAA,qBAAW,IAAIC,IAAI,EAAE,CAACC,kBAAkB,EAAE;IAAA;MAAA;MAAA;MAAA;IAAA,QAAM;EAAA;IAAA;IAAA;IAAA;EAAA,QAEvD;EACD;EACA,OAAOf,IAAI,CAACgB,MAAM,CAACH,WAAW,CAAC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACAb,IAAI,CAACgB,MAAM,CAACZ,OAAO,CAAC;AACpBJ,IAAI,CAACgB,MAAM,CAACN,WAAW,CAACJ,IAAI,CAAC,CAAC;AAC9BN,IAAI,CAACgB,MAAM,CAACL,cAAc,CAAC;AAC3BX,IAAI,CAACgB,MAAM,eAAC,QAAC,GAAG;EAAA;EAAA;EAAA;AAAA,QAAE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}