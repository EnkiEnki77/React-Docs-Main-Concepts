{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\EnkiE\\\\Documents\\\\builds\\\\react-docs-main-concepts\\\\src\\\\components\\\\Counter.js\";\nimport React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      favorite: true\n    };\n\n    // this.increment = this.increment.bind(this)\n  }\n\n  // Your event handlers should be a method on the class, class methods are not bound to the this of the class by default though.\n  // You should bind them manually in the constructor. Otherwise this will be undefined when you go to pass them to an event listener. \n  // There are two ways to get around binding, wrap the event handler instance in a callback AF that invokes it, or make the event \n  // handler an arrow function, arrow functions have a lexical this, meaning they take on the this of the top level of the class. \n  // Using arrow functions for methods is also known as public class fields syntax. Dont use the second way if passing to a child\n  // through props, it may cause a second rerender. \n  // Its common in instances such as a loop to want to pass additional arguments to an event handler, this is one instance where\n  // using the second way is needed ex: onClick((e) => this.increment(id, e)), if doing this in a class you can also just bind \n  // this and the argument to the handler tho. onClick(this.increment.bind(this, id)), in both instances e is the second argument. \n  // in the arrow function example you must explicitly define e. \n  increment() {\n    // Multiple setState calls would generally each trigger a rerender from React, but if youre making multiple seState calls in one\n    // component at once this can be very ineffecient and cause a component and its children to rerender more than needed. So now\n    // all set state calls in a component are batched into one update in order to prevent unnecessary rerenders. This makes setState\n    // asynchronous, because of this you cannot rely on current state to calculate next state, such as in a counter. THis is because\n    // when setState is added to the callback queue it is passed the current state at the time of it being invoked. So even if you \n    // made 100 calls to increment a count state none of them have actually changed the state by the time the last one is invoked, \n    // so the count will still only ever increment by 1\n    // both calls rely on current state at time of the call for incrementing, because setState is async you can make this call\n    // infinite times, but none of the calls will know about the incrementation done by any of the others, so the state will only \n    // increment once per event\n    this.setState({\n      count: this.state.count + this.props.increment\n    });\n    this.setState({\n      count: this.state.count + this.props.increment\n    });\n    console.log(this.state.count);\n\n    // There is a callback you can pass to setState, it takes in the previous state from the output of last setState call, and the \n    // current props at time of update as inputs. It always operates based off the output of the last setState call, so if you \n    // had 4 other setState calls before it that were also utilizing the call back it would increment by 5, but putting just\n    // one call that doesnt utilize the callback between them would make it increment only by 2, this is because without the callback \n    // the setState call wouldnt know about the state outputted by the 4 calls before it, and would operate off the current state \n    // of 0. Meaning the last setState call which utilizes the callback would be working with a prevState of 1. \n    // this.setState((prev, props) => ({count: prev.count + props.increment}))\n    // this.setState((prev, props) => ({count: prev.count + props.increment}))\n    // this.setState((prev, props) => ({count: prev.count + props.increment}))\n    // this.setState((prev, props) => ({count: prev.count + props.increment}))\n    // this.setState({count: this.state.count + this.props.increment})\n    // this.setState((prev, props) => ({count: prev.count + props.increment}))\n\n    // when you call setState React merges the object you provide with the current state. So if you have multiple states defined.\n    // in this.state you can make individual setState calls to change those states and only the states referenced in those calls \n    // will be changed. \n    // if your state is this.state = {count: 0, favorite: true} like in this componnet for example. You could make this setState call\n    this.setState({\n      favorite: false\n    });\n    // This is what it would actually be converted to under the hood before setting the state. A shallow merge\n    this.setState(prevState => ({\n      ...prevState,\n      favorite: false\n    }));\n    // And the state would then be this this.state = {count: 0, favorite: false}\n  }\n\n  // Neither child nor parent should need to know whether a component is stateful or not, state is encapsulated entirely within \n  // the component it is defined, and can only be changed from that component. State data may be passed to children as props. \n  // This does not give the child any indication that its props are state or where they came from though. \n  // React has a unidirectional data flow, meaning that state is always owned by the component it is defined, and any data derived\n  // from state can only be passed downwards through props. \n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        children: \"-\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 72,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n        children: this.state.count\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 73,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.increment,\n        children: \"+\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 78,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 71,\n      columnNumber: 13\n    }, this);\n  }\n}\n\n//  const Count = (props) => {\n//     const [count, setCount] = React.useState(0)\n\n//     const increment = () => {\n//         setCount(count + props.increment)\n//         setCount(count + props.increment)\n//         setCount(prev => prev + props.increment)\n//         console.log(count)\n//     }\n\n//     return (\n//         <div>\n//             <button>-</button>\n//             <h1>{count}</h1>\n//             <button onClick={increment}>+</button>\n//         </div>\n//     )\n// }","map":{"version":3,"names":["React","Counter","Component","constructor","props","state","count","favorite","increment","setState","console","log","prevState","render"],"sources":["C:/Users/EnkiE/Documents/builds/react-docs-main-concepts/src/components/Counter.js"],"sourcesContent":["import React from 'react'\r\n\r\nexport default class Counter extends React.Component {\r\n    constructor(props) {\r\n        super(props) \r\n        this.state = {\r\n            count: 0,\r\n            favorite: true\r\n        }\r\n\r\n        // this.increment = this.increment.bind(this)\r\n    }\r\n\r\n   \r\n   \r\n    // Your event handlers should be a method on the class, class methods are not bound to the this of the class by default though.\r\n    // You should bind them manually in the constructor. Otherwise this will be undefined when you go to pass them to an event listener. \r\n    // There are two ways to get around binding, wrap the event handler instance in a callback AF that invokes it, or make the event \r\n    // handler an arrow function, arrow functions have a lexical this, meaning they take on the this of the top level of the class. \r\n    // Using arrow functions for methods is also known as public class fields syntax. Dont use the second way if passing to a child\r\n    // through props, it may cause a second rerender. \r\n    // Its common in instances such as a loop to want to pass additional arguments to an event handler, this is one instance where\r\n    // using the second way is needed ex: onClick((e) => this.increment(id, e)), if doing this in a class you can also just bind \r\n    // this and the argument to the handler tho. onClick(this.increment.bind(this, id)), in both instances e is the second argument. \r\n    // in the arrow function example you must explicitly define e. \r\n    increment() {\r\n        // Multiple setState calls would generally each trigger a rerender from React, but if youre making multiple seState calls in one\r\n        // component at once this can be very ineffecient and cause a component and its children to rerender more than needed. So now\r\n        // all set state calls in a component are batched into one update in order to prevent unnecessary rerenders. This makes setState\r\n        // asynchronous, because of this you cannot rely on current state to calculate next state, such as in a counter. THis is because\r\n        // when setState is added to the callback queue it is passed the current state at the time of it being invoked. So even if you \r\n        // made 100 calls to increment a count state none of them have actually changed the state by the time the last one is invoked, \r\n        // so the count will still only ever increment by 1\r\n        // both calls rely on current state at time of the call for incrementing, because setState is async you can make this call\r\n        // infinite times, but none of the calls will know about the incrementation done by any of the others, so the state will only \r\n        // increment once per event\r\n        this.setState({count: this.state.count + this.props.increment})\r\n        this.setState({count: this.state.count + this.props.increment})\r\n        console.log(this.state.count)\r\n\r\n        // There is a callback you can pass to setState, it takes in the previous state from the output of last setState call, and the \r\n        // current props at time of update as inputs. It always operates based off the output of the last setState call, so if you \r\n        // had 4 other setState calls before it that were also utilizing the call back it would increment by 5, but putting just\r\n        // one call that doesnt utilize the callback between them would make it increment only by 2, this is because without the callback \r\n        // the setState call wouldnt know about the state outputted by the 4 calls before it, and would operate off the current state \r\n        // of 0. Meaning the last setState call which utilizes the callback would be working with a prevState of 1. \r\n        // this.setState((prev, props) => ({count: prev.count + props.increment}))\r\n        // this.setState((prev, props) => ({count: prev.count + props.increment}))\r\n        // this.setState((prev, props) => ({count: prev.count + props.increment}))\r\n        // this.setState((prev, props) => ({count: prev.count + props.increment}))\r\n        // this.setState({count: this.state.count + this.props.increment})\r\n        // this.setState((prev, props) => ({count: prev.count + props.increment}))\r\n\r\n        // when you call setState React merges the object you provide with the current state. So if you have multiple states defined.\r\n        // in this.state you can make individual setState calls to change those states and only the states referenced in those calls \r\n        // will be changed. \r\n        // if your state is this.state = {count: 0, favorite: true} like in this componnet for example. You could make this setState call\r\n        this.setState({favorite: false})\r\n        // This is what it would actually be converted to under the hood before setting the state. A shallow merge\r\n        this.setState(prevState => ({...prevState, favorite: false}))\r\n        // And the state would then be this this.state = {count: 0, favorite: false}\r\n    }\r\n\r\n    // Neither child nor parent should need to know whether a component is stateful or not, state is encapsulated entirely within \r\n    // the component it is defined, and can only be changed from that component. State data may be passed to children as props. \r\n    // This does not give the child any indication that its props are state or where they came from though. \r\n    // React has a unidirectional data flow, meaning that state is always owned by the component it is defined, and any data derived\r\n    // from state can only be passed downwards through props. \r\n    render() {\r\n        return (\r\n            <div>\r\n                <button>-</button>\r\n                <h1>{this.state.count}</h1>\r\n                {/* Handling events in React is very similar to how its done with DOM elements, except the naming convention is \r\n                camelCase, and with JSX you pass a function as the eventHandler instead of a string. You also cant return false to \r\n                prevent default behaviour. You have to call the event.preventDefault method explicitly. The event object is a synthetic \r\n                event passed into the event handler from the JSX node the event is occuring. */}\r\n                <button onClick={this.increment}>+</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n//  const Count = (props) => {\r\n//     const [count, setCount] = React.useState(0)\r\n\r\n//     const increment = () => {\r\n//         setCount(count + props.increment)\r\n//         setCount(count + props.increment)\r\n//         setCount(prev => prev + props.increment)\r\n//         console.log(count)\r\n//     }\r\n\r\n//     return (\r\n//         <div>\r\n//             <button>-</button>\r\n//             <h1>{count}</h1>\r\n//             <button onClick={increment}>+</button>\r\n//         </div>\r\n//     )\r\n// }\r\n\r\n"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AAAA;AAEzB,eAAe,MAAMC,OAAO,SAASD,KAAK,CAACE,SAAS,CAAC;EACjDC,WAAW,CAACC,KAAK,EAAE;IACf,KAAK,CAACA,KAAK,CAAC;IACZ,IAAI,CAACC,KAAK,GAAG;MACTC,KAAK,EAAE,CAAC;MACRC,QAAQ,EAAE;IACd,CAAC;;IAED;EACJ;;EAIA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,SAAS,GAAG;IACR;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,CAACC,QAAQ,CAAC;MAACH,KAAK,EAAE,IAAI,CAACD,KAAK,CAACC,KAAK,GAAG,IAAI,CAACF,KAAK,CAACI;IAAS,CAAC,CAAC;IAC/D,IAAI,CAACC,QAAQ,CAAC;MAACH,KAAK,EAAE,IAAI,CAACD,KAAK,CAACC,KAAK,GAAG,IAAI,CAACF,KAAK,CAACI;IAAS,CAAC,CAAC;IAC/DE,OAAO,CAACC,GAAG,CAAC,IAAI,CAACN,KAAK,CAACC,KAAK,CAAC;;IAE7B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA,IAAI,CAACG,QAAQ,CAAC;MAACF,QAAQ,EAAE;IAAK,CAAC,CAAC;IAChC;IACA,IAAI,CAACE,QAAQ,CAACG,SAAS,KAAK;MAAC,GAAGA,SAAS;MAAEL,QAAQ,EAAE;IAAK,CAAC,CAAC,CAAC;IAC7D;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACAM,MAAM,GAAG;IACL,oBACI;MAAA,wBACI;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QAAkB,eAClB;QAAA,UAAK,IAAI,CAACR,KAAK,CAACC;MAAK;QAAA;QAAA;QAAA;MAAA,QAAM,eAK3B;QAAQ,OAAO,EAAE,IAAI,CAACE,SAAU;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QAAW;IAAA;MAAA;MAAA;MAAA;IAAA,QACzC;EAEd;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}