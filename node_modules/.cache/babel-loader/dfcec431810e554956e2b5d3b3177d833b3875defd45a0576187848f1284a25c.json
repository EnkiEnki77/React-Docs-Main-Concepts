{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\EnkiE\\\\Documents\\\\builds\\\\react-docs-main-concepts\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { Component } from 'react';\nimport './App.css';\nimport Comment from './components/Comment';\nimport { Clock, ClockClass } from './components/Clock';\nimport ElementComponent from './components/Element';\nimport Welcome from './components/Welcome';\nimport Counter from './components/Counter';\nimport Count from './components/Counter';\nimport NameForm from './components/NameForm';\n\n// Components allow you to split the UI up into independent, reusable pieces in which you can think about in isolation based on their\n// functionality/purpose within the application. They can be seen as functions that take in arbitrary inputs called props, and return\n// React elements that describe the UI. They can also be used to define the UI logic for those elements. There are two kinds of components.\n\n// This is a React functional component.\n// This function is a valid component, because it takes an optional props object input, and returns a single React element. Components\n// can only return one element, so any additional elements youd like that component to encapsulate should be children.  \nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst App = props => {\n  _s();\n  const author = {\n    avatarUrl: '',\n    name: 'John'\n  };\n  const numbers = [1, 2, 3, 4];\n  const [counterSwitch, setCounterSwitch] = React.useState(true);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(ElementComponent, {\n      name: \"Sara\",\n      children: /*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"I am a child of the ElementComponent\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 39,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(Welcome, {\n      name: \"Bob\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 45,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(Welcome, {\n      name: \"Snowy\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 46,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(Welcome, {\n      name: \"Enki\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 47,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(Comment, {\n      author: author,\n      text: \"hi bitches\",\n      date: new Date().toLocaleDateString()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 49,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(Clock, {\n      date: new Date()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 51,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(ClockClass, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 52,\n      columnNumber: 9\n    }, this), counterSwitch ? /*#__PURE__*/_jsxDEV(Counter, {\n      increment: 1\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 60,\n      columnNumber: 26\n    }, this) : /*#__PURE__*/_jsxDEV(Counter, {\n      increment: 2\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 60,\n      columnNumber: 54\n    }, this), /*#__PURE__*/_jsxDEV(Counter, {\n      increment: 5\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 10\n    }, this), counterSwitch && /*#__PURE__*/_jsxDEV(Counter, {\n      increment: 2\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 28\n    }, this), numbers.map(number => /*#__PURE__*/_jsxDEV(Counter, {\n      increment: number\n    }, number.toString(), false, {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 32\n    }, this)), /*#__PURE__*/_jsxDEV(NameForm, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 77,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 28,\n    columnNumber: 5\n  }, this);\n};\n\n// This is a React class component.\n// class based components are similar to function components in that they take in a props object input, return a React element.\n// props are recieved through the class constructor, and elements are returned from a render() method.\n_s(App, \"rXuziKzLsM7UuN7jWJld/RYh57k=\");\n_c = App;\nclass ClassApp extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App\",\n      children: \"class App\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 93,\n      columnNumber: 13\n    }, this);\n  }\n}\n\n// This is how you export things such as components as modules to be imported in other files. export default can only take one thing\n// it makes it the primary module of the file. export can take as many things as youd like, but they must be destructured from the\n// file on import. \nexport default App;\n\n// The render cycle is as follows:\n// 1. root.render() is called with <App/> as it's input.\n// 2. <App/> is called with null as its props.\n// 3. <App/> returns <div> element, that element is converted to a React.createElement() call with the following input.\n// React.createElement(\n// 'div',\n// {className: 'App'},\n// <Children/>\n// )\n// 4. any children that represent jsx dom tags are converted to createElement calls themselves, any children that are references to\n// components go through the same process as App, and return elements that convert to createElement calls.\n// 5. ReactDOM takes the tree of React element objects and uses them to tell the DOM what to look like.\n// 6. Whenever a save is made in your editor the source code is recompiled, and a new tree is created. React recursively goes through\n// the old tree. Any elemnts that have changes to props/children are updated, and the element along with its children are rerendered.\n// Any elemnents that have not changed are not rerenderd, because they already have been. \nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","Component","Comment","Clock","ClockClass","ElementComponent","Welcome","Counter","Count","NameForm","App","props","author","avatarUrl","name","numbers","counterSwitch","setCounterSwitch","useState","Date","toLocaleDateString","map","number","toString","ClassApp","constructor","render"],"sources":["C:/Users/EnkiE/Documents/builds/react-docs-main-concepts/src/App.js"],"sourcesContent":["import React, { Component } from 'react'\r\nimport './App.css'\r\nimport Comment from './components/Comment'\r\nimport { Clock, ClockClass } from './components/Clock'\r\nimport ElementComponent from './components/Element'\r\nimport Welcome from './components/Welcome'\r\nimport Counter from './components/Counter'\r\nimport Count from './components/Counter'\r\nimport NameForm from './components/NameForm'\r\n\r\n// Components allow you to split the UI up into independent, reusable pieces in which you can think about in isolation based on their\r\n// functionality/purpose within the application. They can be seen as functions that take in arbitrary inputs called props, and return\r\n// React elements that describe the UI. They can also be used to define the UI logic for those elements. There are two kinds of components.\r\n\r\n// This is a React functional component.\r\n// This function is a valid component, because it takes an optional props object input, and returns a single React element. Components\r\n// can only return one element, so any additional elements youd like that component to encapsulate should be children.  \r\nconst App = (props) => {\r\n    const author = {\r\n        avatarUrl: '',\r\n        name: 'John'\r\n    }\r\n\r\n    const numbers = [1, 2, 3, 4]\r\n\r\n    const [counterSwitch, setCounterSwitch] = React.useState(true)\r\n  return (\r\n    <div className=\"App\">\r\n        {/* Because Components are functions that return elements they can be imported to other files, and utilized as JSx the same way\r\n        an element can be, because on compilation they are just the returned element, containing any of the state/props logic embedded\r\n        into them. */}\r\n        {/* When React sees an element representing a component it passes JSX attributes and children to this component as an object \r\n        This object is called props*/}\r\n        {/* Components can be utilized as just a single tag, or with open and closing tags. For the latter, any elements passed here\r\n        will be assigned to props.children */}\r\n        {/* Elements that represent a component must be capitalized, otherwise they are treated as DOM tags. They component they\r\n        represent must also be imported/in scope. */}\r\n        <ElementComponent name='Sara'>\r\n            <h2>I am a child of the ElementComponent</h2>\r\n        </ElementComponent>\r\n\r\n        {/* Components can refer to other components in their output. This lets us reuse the same components in many places for any\r\n        level of detail. For a button, a form, a screen, etc. Each reference to a component will be treated as a seperate element,\r\n        meaning you can pass different props to each reference. */}\r\n        <Welcome name='Bob'/>\r\n        <Welcome name='Snowy'/>\r\n        <Welcome name='Enki'/>\r\n\r\n        <Comment author={author} text='hi bitches' date={new Date().toLocaleDateString()}/>\r\n\r\n        <Clock date={new Date()}/>\r\n        <ClockClass/>\r\n\r\n        {/* Components are truly isolated, so even though im putting two Counters here which are both referencing the same component\r\n        They are different instances of that componnet, and so have their own state and lifecycle */}\r\n        {/* I can conditionally render components based on the current state of the component rendering them. */}\r\n        {/* This is an if else conditional render utilizing ternary operator, allows you to decide bewtween two elements depending on \r\n        state. You can chain these into multiple if else statements, but remember if conditions become too complex you should just extract\r\n        a component.*/}\r\n        {counterSwitch ? <Counter increment={1}/> :  <Counter increment={2}/>}\r\n         <Counter increment={5}/>\r\n        {/* This is an && conditionl render, used to conditional render one element based on if a condition evaluates to true.\r\n        This works because true && expression always evaluates to expression, and false && expression evaluates to false.\r\n        Be careful with this because using a falsey expression on the left said the falsey expression will be rendered into the JSX*/}\r\n        {counterSwitch &&  <Counter increment={2}/>}\r\n        \r\n        {/* You can render a list of elements based on an array using the map method, this allows you to create a component for\r\n        each key of the array, and pass the value of that key into the component as props.*/}\r\n        {/* when rendering components in this way each item in the list requires a unique key, this allows React to identify which\r\n        items have changed, been added, or been removed. The best thing to use as a key is a string that uniquely identifies an item\r\n        from its sibling, most often youd use an id from the array data. If not stable id is present you can use the index from map.\r\n        This isnt recommended if the order of items may change though, it can effect performance and components state. If a key isnt \r\n        provided React defaults to using indexes*/}\r\n        {/* Keys serve as hints to React, but arent passed to your components props, if you need the same value pass a different prop*/}\r\n        {numbers.map(number => <Counter increment={number} key={number.toString()}/>)}\r\n\r\n        <NameForm/>\r\n    </div>\r\n  )\r\n}\r\n\r\n\r\n// This is a React class component.\r\n// class based components are similar to function components in that they take in a props object input, return a React element.\r\n// props are recieved through the class constructor, and elements are returned from a render() method.\r\nclass ClassApp extends React.Component {\r\n    constructor(props){\r\n        super(props)\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div className=\"App\">\r\n                class App \r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n// This is how you export things such as components as modules to be imported in other files. export default can only take one thing\r\n// it makes it the primary module of the file. export can take as many things as youd like, but they must be destructured from the\r\n// file on import. \r\nexport default App\r\n\r\n\r\n// The render cycle is as follows:\r\n// 1. root.render() is called with <App/> as it's input.\r\n// 2. <App/> is called with null as its props.\r\n// 3. <App/> returns <div> element, that element is converted to a React.createElement() call with the following input.\r\n// React.createElement(\r\n    // 'div',\r\n    // {className: 'App'},\r\n    // <Children/>\r\n// )\r\n// 4. any children that represent jsx dom tags are converted to createElement calls themselves, any children that are references to\r\n// components go through the same process as App, and return elements that convert to createElement calls.\r\n// 5. ReactDOM takes the tree of React element objects and uses them to tell the DOM what to look like.\r\n// 6. Whenever a save is made in your editor the source code is recompiled, and a new tree is created. React recursively goes through\r\n// the old tree. Any elemnts that have changes to props/children are updated, and the element along with its children are rerendered.\r\n// Any elemnents that have not changed are not rerenderd, because they already have been. "],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,SAAS,QAAQ,OAAO;AACxC,OAAO,WAAW;AAClB,OAAOC,OAAO,MAAM,sBAAsB;AAC1C,SAASC,KAAK,EAAEC,UAAU,QAAQ,oBAAoB;AACtD,OAAOC,gBAAgB,MAAM,sBAAsB;AACnD,OAAOC,OAAO,MAAM,sBAAsB;AAC1C,OAAOC,OAAO,MAAM,sBAAsB;AAC1C,OAAOC,KAAK,MAAM,sBAAsB;AACxC,OAAOC,QAAQ,MAAM,uBAAuB;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA,MAAMC,GAAG,GAAIC,KAAK,IAAK;EAAA;EACnB,MAAMC,MAAM,GAAG;IACXC,SAAS,EAAE,EAAE;IACbC,IAAI,EAAE;EACV,CAAC;EAED,MAAMC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAE5B,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGjB,KAAK,CAACkB,QAAQ,CAAC,IAAI,CAAC;EAChE,oBACE;IAAK,SAAS,EAAC,KAAK;IAAA,wBAUhB,QAAC,gBAAgB;MAAC,IAAI,EAAC,MAAM;MAAA,uBACzB;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA;IAA6C;MAAA;MAAA;MAAA;IAAA,QAC9B,eAKnB,QAAC,OAAO;MAAC,IAAI,EAAC;IAAK;MAAA;MAAA;MAAA;IAAA,QAAE,eACrB,QAAC,OAAO;MAAC,IAAI,EAAC;IAAO;MAAA;MAAA;MAAA;IAAA,QAAE,eACvB,QAAC,OAAO;MAAC,IAAI,EAAC;IAAM;MAAA;MAAA;MAAA;IAAA,QAAE,eAEtB,QAAC,OAAO;MAAC,MAAM,EAAEN,MAAO;MAAC,IAAI,EAAC,YAAY;MAAC,IAAI,EAAE,IAAIO,IAAI,EAAE,CAACC,kBAAkB;IAAG;MAAA;MAAA;MAAA;IAAA,QAAE,eAEnF,QAAC,KAAK;MAAC,IAAI,EAAE,IAAID,IAAI;IAAG;MAAA;MAAA;MAAA;IAAA,QAAE,eAC1B,QAAC,UAAU;MAAA;MAAA;MAAA;IAAA,QAAE,EAQZH,aAAa,gBAAG,QAAC,OAAO;MAAC,SAAS,EAAE;IAAE;MAAA;MAAA;MAAA;IAAA,QAAE,gBAAI,QAAC,OAAO;MAAC,SAAS,EAAE;IAAE;MAAA;MAAA;MAAA;IAAA,QAAE,eACpE,QAAC,OAAO;MAAC,SAAS,EAAE;IAAE;MAAA;MAAA;MAAA;IAAA,QAAE,EAIxBA,aAAa,iBAAK,QAAC,OAAO;MAAC,SAAS,EAAE;IAAE;MAAA;MAAA;MAAA;IAAA,QAAE,EAU1CD,OAAO,CAACM,GAAG,CAACC,MAAM,iBAAI,QAAC,OAAO;MAAC,SAAS,EAAEA;IAAO,GAAMA,MAAM,CAACC,QAAQ,EAAE;MAAA;MAAA;MAAA;IAAA,QAAG,CAAC,eAE7E,QAAC,QAAQ;MAAA;MAAA;MAAA;IAAA,QAAE;EAAA;IAAA;IAAA;IAAA;EAAA,QACT;AAEV,CAAC;;AAGD;AACA;AACA;AAAA,GAnEMb,GAAG;AAAA,KAAHA,GAAG;AAoET,MAAMc,QAAQ,SAASxB,KAAK,CAACC,SAAS,CAAC;EACnCwB,WAAW,CAACd,KAAK,EAAC;IACd,KAAK,CAACA,KAAK,CAAC;EAChB;EAEAe,MAAM,GAAE;IACJ,oBACI;MAAK,SAAS,EAAC,KAAK;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QAEd;EAEd;AACJ;;AAEA;AACA;AACA;AACA,eAAehB,GAAG;;AAGlB;AACA;AACA;AACA;AACA;AACI;AACA;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}